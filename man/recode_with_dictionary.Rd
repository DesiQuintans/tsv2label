% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa_recode_with_dictionary.R
\name{recode_with_dictionary}
\alias{recode_with_dictionary}
\title{Recode variables with a data dictionary}
\usage{
recode_with_dictionary(df, path, up = 2)
}
\arguments{
\item{df}{(Dataframe) A dataframe to label.}

\item{path}{(Character) Path to the dataset's dictionary files, which is
either a folder or a .zip file. See \link{expected_files} for more info.}

\item{up}{(Integer) The number of environments to step back in, determining
where this function will be evaluated. See \code{\link[=parent.frame]{parent.frame()}} for details.
The default value of \code{up = 2} is usually appropriate.}
}
\value{
Mutates \code{df} in-place in the specified environment.
}
\description{
'Recoding a variable' means re-interpreting it from its original data type
(e.g. \code{"Yes"}s and \code{"No"}s) into a different type that is appropriate for
analysis in R (e.g. \code{TRUE} and \code{FALSE}, or a Factor). This can be done in
two ways:
\enumerate{
\item A \strong{mapping spreadsheet} can be used, which defines how the unique values
of the variable are assigned to Factor levels, just like \code{\link[=factor]{factor()}}.
\item A \strong{converter} can be used. Converters are built-in mapping tables that can
convert to Factor and Logical for common use-cases. For example, the
\verb{<truefalse>} converter recodes a variable into Logical. See 'Details' for
a list of accepted converters.
}
}
\details{
Recoding with a mapping spreadsheet can produce a large number of unused factor
levels, e.g. converting \code{country_of_residence} to a factor using a dictionary
of hundreds of countries, but your dataset only contains people from Australia.
Use the base function \code{\link[=droplevels]{droplevels()}} to remove unused levels (see 'Examples').
\subsection{Accepted converters}{

These converters work on 'truthy' and 'falsy' values, ignoring case. 'Truthy'
values are \verb{\{1, y, yes, t, true\}}. 'Falsy' values are \verb{\{0, n, no, f, false\}}.
\itemize{
\item \strong{\verb{<truefalse>}}      : Converts truthy values to \code{TRUE}, falsy values to
\code{FALSE}, everything else (including \code{NA}) to \code{NA}.
\item \strong{\verb{<truefalse-lazy>}} : Converts truthy values to \code{TRUE} and everything
else to \code{FALSE}, but preserves \code{NA} as \code{NA}.
\item \strong{\verb{<yesno>}}          : Converts truthy values to factor level \code{"Yes"},
falsy values to factor level \code{"No"}, and everything else (including \code{NA})
to \code{NA}. \code{"Yes"} is the first factor level.
\item \strong{\verb{<noyes>}}          : Same as above, but with \code{"No"} as the first factor level.
\item \strong{\verb{<yesno-lazy>}}     : Converts truthy values to factor level \code{"Yes"} and
everything else to factor level \code{"No"}, but preserves \code{NA} as \code{NA}. \code{"Yes"}
is the first factor level.
\item \strong{\verb{<noyes-lazy>}}     : Same as above, but with \code{"No"} as the first factor level.
}
}
}
\examples{
\donttest{
# An unlabelled dataset that is built-into this package.
my_poker <- poker

# system.file() gives the path to a dictionary for this dataset that is also
# built-into this package.
recode_with_dictionary(my_poker, system.file("extdata/poker", package = "tsv2label"))

##  (1/6)  Using '<noyes-lazy>' for LOGICAL_INT.
##  (2/6)  Using '<truefalse>' for LOGICAL_CHAR, yesno.
##  (3/6)  Using 'values_flip' for COIN FLIP.
##  (4/6)  Using 'values_hands' for CLASS.
##  (5/6)  Using 'values_ranks' for C1, C2, C3, C4, C5.
##  (6/6)  Using 'values_suits' for S1, S2, S3, S4, S5.
##
##  Peeking at 'levels(my_poker[["LOGICAL_INT"]])', built from
##  '<noyes-lazy>':
##  No, Yes
##
##  Peeking at 'unique(my_poker[["LOGICAL_CHAR"]])', built from
##  '<truefalse>':
##  TRUE, NA, FALSE
##
##  Peeking at 'levels(my_poker[["COIN FLIP"]])', built from
##  'values_flip':
##  Heads, Tails
##
##  Peeking at 'levels(my_poker[["CLASS"]])', built from
##  'values_hands':
##  Nothing in hand, One pair, Two pairs, Three of a kind,
##  Straight, Flush, Full house, Four of a kind, Straight
##  flush, Royal flush
##
##  Peeking at 'levels(my_poker[["C1"]])', built from
##  'values_ranks':
##  Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King
##
##  Peeking at 'levels(my_poker[["S1"]])', built from
##  'values_suits':
##  Hearts, Spades, Diamonds, Clubs

# Drop all unused levels from every column of a dataframe
my_poker <- droplevels(my_poker)
}
}
\seealso{
\code{\link[=droplevels]{droplevels()}}
}
